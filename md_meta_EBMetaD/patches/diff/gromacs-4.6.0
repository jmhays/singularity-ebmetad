patch -c -l -b -F 3 --suffix=.preplumed "./src/kernel/repl_ex.c" << \EOF_EOF
*** ./src/kernel/repl_ex.c.preplumed	2012-04-25 16:22:16.342989671 +0100
--- ./src/kernel/repl_ex.c	2012-04-26 11:24:54.425865975 +0100
***************
*** 51,56 ****
--- 51,59 ----
  #include "domdec.h"
  #include "partdec.h"
  
+ // to include metadynamics variables
+ #include "metadyn.h"
+ 
  typedef struct gmx_repl_ex
  {
      int  repl;
***************
*** 82,95 ****
      qall[re->repl] = q;
      gmx_sum_sim(ms->nsim,qall,ms);
  
!     bDiff = FALSE;
!     for(s=1; s<ms->nsim; s++)
!     {
!         if (qall[s] != qall[0])
!         {
              bDiff = TRUE;
!         }
!     }
      if (bDiff)
      {
          if (re->type >= 0 && re->type < ereNR)
--- 85,98 ----
      qall[re->repl] = q;
      gmx_sum_sim(ms->nsim,qall,ms);
  
!     //bDiff = FALSE;
!     //for(s=1; s<ms->nsim; s++)
!     //{
!     //    if (qall[s] != qall[0])
!     //    {
              bDiff = TRUE;
!     //    }
!     //}
      if (bDiff)
      {
          if (re->type >= 0 && re->type < ereNR)
***************
*** 162,175 ****
          case ereTEMP:
              repl_quantity(fplog,ms,re,i,re->temp);
              break;
!         case ereLAMBDA:
!             if (ir->efep != efepNO)
!             {
!                 repl_quantity(fplog,ms,re,i,ir->init_lambda);
!             }
!             break;
!         default:
!             gmx_incons("Unknown replica exchange quantity");
          }
      }
      if (re->type == -1)
--- 165,178 ----
          case ereTEMP:
              repl_quantity(fplog,ms,re,i,re->temp);
              break;
! //       case ereLAMBDA:
! //           if (ir->efep != efepNO)
! //           {
! //               repl_quantity(fplog,ms,re,i,ir->init_lambda);
! //           }
! //           break;
! //       default:
! //           gmx_incons("Unknown replica exchange quantity");
          }
      }
      if (re->type == -1)
***************
*** 232,237 ****
--- 235,244 ----
      {
          re->ind[i] = i;
      }
+   /* Carlo Wed Oct 10 14:37:58 CEST 2007 */
+   /* This code is commented out to permit replicas with same temperature */
+   /* It's usefull for Replica Metadynamics (Laio's way) */
+   /*
      for(i=0; i<re->nrepl; i++)
      {
          for(j=i+1; j<re->nrepl; j++)
***************
*** 248,253 ****
--- 255,261 ----
              }
          }
      }
+     */
      fprintf(fplog,"Repl   ");
      for(i=0; i<re->nrepl; i++)
      {
***************
*** 581,586 ****
--- 589,600 ----
      gmx_bool *bEx,bPrint;
      int  exchange;
  
+   /* Carlo Wed Oct 10 14:37:58 CEST 2007 */
+   /* Replica-methods stuff */
+   real delta1=0., delta2=0., delta_meta=0.;
+   int target_replica;
+   real *Vbias=NULL,*Vbiasx=NULL;
+ 
      fprintf(fplog,"Replica exchange at step %d time %g\n",step,time);
    
      switch (re->type)
***************
*** 605,610 ****
--- 619,645 ----
  
      exchange = -1;
      m = (step / re->nst) % 2;
+ 
+   if(logical.rpxm) bias_exchange_traj(re->nrepl, &(re->seed), re->ind);
+ 
+   snew(Vbias,re->nrepl);
+   snew(Vbiasx,re->nrepl);
+ 
+   if(logical.remd) {
+     for(i=0; i<re->nrepl; i++) Vbias[i]=0.;
+     for(i=0; i<re->nrepl; i++) Vbiasx[i]=0.;
+     target_replica=-1; // means NO exchange;
+     for(i=1; i<re->nrepl; i++) {
+       a = re->ind[i-1];
+       b = re->ind[i];
+       if (i % 2 == m) {
+         if(re->repl==a) target_replica=b;
+         if(re->repl==b) target_replica=a;
+       }
+     };
+     ptmetad_vbias(target_replica,Vbias,Vbiasx);
+   }
+   
      for(i=1; i<re->nrepl; i++)
      {
          a = re->ind[i-1];
***************
*** 615,627 ****
              switch (re->type)
              {
              case ereTEMP:
                  /* Use equations from:
                   * Okabe et. al. Chem. Phys. Lett. 335 (2001) 435-439
                   */
                  ediff = Epot[b] - Epot[a];
!                 betaA = 1.0/(re->q[a]*BOLTZ);
!                 betaB = 1.0/(re->q[b]*BOLTZ);
!                 delta = (betaA - betaB)*ediff;
                  break;
              case ereLAMBDA:
                  /* Here we exchange based on a linear extrapolation of dV/dlambda.
--- 650,667 ----
              switch (re->type)
              {
              case ereTEMP:
+ /* metadynamics contribution */
+         delta1 = Vbias[a]-Vbiasx[a];
+         delta2 = Vbias[b]-Vbiasx[b];
+         betaA = 1.0/(re->q[a]*BOLTZ);
+         betaB = 1.0/(re->q[b]*BOLTZ);
+         delta_meta = betaA * delta1 + betaB * delta2;
                  /* Use equations from:
                   * Okabe et. al. Chem. Phys. Lett. 335 (2001) 435-439
                   */
                  ediff = Epot[b] - Epot[a];
! 	delta = (betaA - betaB)*ediff-delta_meta;
! 
                  break;
              case ereLAMBDA:
                  /* Here we exchange based on a linear extrapolation of dV/dlambda.
***************
*** 688,697 ****
--- 728,741 ----
              bEx[i] = FALSE;
          }
      }
+   if(logical.widthadapt) ptmetad_exchfluct(exchange);
      print_ind(fplog,"ex",re->nrepl,re->ind,bEx);
      print_prob(fplog,"pr",re->nrepl,prob);
      fprintf(fplog,"\n");
  
+   sfree(Vbias);
+   sfree(Vbiasx);
+ 
      sfree(bEx);
      sfree(prob);
      sfree(Epot);
***************
*** 719,725 ****
          exchange = get_replica_exchange(fplog,ms,re,ener,det(state->box),
                                          step,time);
          bExchanged = (exchange >= 0);
!     }
      
      if (PAR(cr))
      {
--- 763,771 ----
          exchange = get_replica_exchange(fplog,ms,re,ener,det(state->box),
                                          step,time);
          bExchanged = (exchange >= 0);
!   } else {
!     if(logical.meta_inp) ptmetad_helper();
!   };
      
      if (PAR(cr))
      {
***************
*** 826,828 ****
--- 872,885 ----
    
      fprintf(fplog,"\n");
  }
+ 
+ int replica_exchange_get_repl(const gmx_repl_ex_t re){
+   return re->repl;
+ };
+ int replica_exchange_get_nrepl(const gmx_repl_ex_t re){
+   return re->nrepl;
+ };
+ real replica_exchange_get_temp(const gmx_repl_ex_t re,int i){
+   return re->q[i];
+ };
+ 
EOF_EOF
patch -c -l -b -F 3 --suffix=.preplumed "./src/kernel/repl_ex.h" << \EOF_EOF
*** ./src/kernel/repl_ex.h.preplumed	2012-04-25 16:22:16.342989671 +0100
--- ./src/kernel/repl_ex.h	2012-04-26 11:24:54.425865975 +0100
***************
*** 69,72 ****
--- 69,77 ----
  extern void pd_distribute_state(const t_commrec *cr,t_state *state);
  /* Distributes the state after exchange for particle decomposition */
  
+ extern int replica_exchange_get_repl(const gmx_repl_ex_t re);
+ extern int replica_exchange_get_nrepl(const gmx_repl_ex_t re);
+ extern real replica_exchange_get_temp(const gmx_repl_ex_t re,int i);
+ /* Interfaces to get replica index, number of replicas and q-value */
+ 
  #endif	/* _repl_ex_h */
EOF_EOF
patch -c -l -b -F 3 --suffix=.preplumed "./src/kernel/md.c" << \EOF_EOF
*** ./src/kernel/md.c.preplumed	2012-04-25 16:22:16.342989671 +0100
--- ./src/kernel/md.c	2012-04-26 11:24:54.425865975 +0100
***************
*** 84,89 ****
--- 84,91 ----
  #include "compute_io.h"
  #include "mvdata.h"
  #include "checkpoint.h"
+ // include PLUMED interface
+ #include "metadyn.h"
  #include "mtop_util.h"
  #include "sighandler.h"
  #include "string2.h"
***************
*** 602,607 ****
--- 604,617 ----
          fprintf(fplog,"\n");
      }
  
+   /* Initialize stuff for metadynamics and replica-methods */
+   if(logical.meta_inp) {
+     /* Initialize metadynamics */
+     init_metadyn(top_global->natoms, ir->ePBC,  mdatoms->chargeA, mdatoms->massT,
+                  ir->delta_t, (repl_ex_nst>0?repl_ex_nst:-1),repl_ex,cr,fplog);
+   }
+ 
+ 
      /* Set and write start time */
      runtime_start(runtime);
      print_date_and_time(fplog,cr->nodeid,"Started mdrun",runtime);
***************
*** 1040,1051 ****
--- 1050,1069 ----
               * This is parallellized as well, and does communication too. 
               * Check comments in sim_util.c
               */
+        // this is necessary since plumed forces are calculated in do_force which
+       // does not have access to step
+       if(logical.meta_inp) plumed_setstep(step,bCPT);
+ 
+ 
               do_force(fplog,cr,ir,step,nrnb,wcycle,top,top_global,groups,
                       state->box,state->x,&state->hist,
                       f,force_vir,mdatoms,enerd,fcd,
                       state->lambda,graph,
                       fr,vsite,mu_tot,t,outf->fp_field,ed,bBornRadii,
                       (bNS ? GMX_FORCE_NS : 0) | force_flags);
+ 
+             if(logical.meta_inp) meta_force_calculation(mdatoms->start,mdatoms->homenr,state->x,f,state->box,enerd->term[F_EPOT], ir->opts.ref_t[0]);
+ 
          }
      
          GMX_BARRIER(cr->mpi_comm_mygroup);
EOF_EOF
patch -c -l -b -F 3 --suffix=.preplumed "./src/kernel/mdrun.c" << \EOF_EOF
*** ./src/kernel/mdrun.c.preplumed	2012-04-25 16:22:16.342989671 +0100
--- ./src/kernel/mdrun.c	2012-04-26 11:24:54.425865975 +0100
***************
*** 55,60 ****
--- 55,61 ----
  
  /* afm stuf */
  #include "pull.h"
+ #include "metadyn.h"
  
  int main(int argc,char *argv[])
  {
***************
*** 383,389 ****
      { efLOG, "-rt",     "rottorque",ffOPTWR },
      { efMTX, "-mtx",    "nm",       ffOPTWR },
      { efNDX, "-dn",     "dipole",   ffOPTWR },
!     { efRND, "-multidir",NULL,      ffOPTRDMULT}
    };
  #define NFILE asize(fnm)
  
--- 384,391 ----
      { efLOG, "-rt",     "rottorque",ffOPTWR },
      { efMTX, "-mtx",    "nm",       ffOPTWR },
      { efNDX, "-dn",     "dipole",   ffOPTWR },
!     { efRND, "-multidir",NULL,      ffOPTRDMULT},
!     { efDAT, "-plumed", "plumed",   ffOPTRD }
    };
  #define NFILE asize(fnm)
  
***************
*** 680,685 ****
--- 682,695 ----
    ddxyz[YY] = (int)(realddxyz[YY] + 0.5);
    ddxyz[ZZ] = (int)(realddxyz[ZZ] + 0.5);
  
+   if (opt2bSet("-plumed",NFILE,fnm)) {
+     logical.meta_inp=1;
+     const char *metaFilename=ftp2fn(efDAT, NFILE, fnm);
+     strcpy(mtd_data.metaFilename,metaFilename);
+   } else {
+     logical.meta_inp=0;
+   }
+ 
    rc = mdrunner(nthreads, fplog,cr,NFILE,fnm,oenv,bVerbose,bCompact,
                  nstglobalcomm, ddxyz,dd_node_order,rdd,rconstr,
                  dddlb_opt[0],dlb_scale,ddcsx,ddcsy,ddcsz,
EOF_EOF
patch -c -l -b -F 3 --suffix=.preplumed "./src/kernel/CMakeLists.txt" << \EOF_EOF
*** ./src/kernel/CMakeLists.txt.preplumed	2012-04-26 10:59:53.657711343 +0100
--- ./src/kernel/CMakeLists.txt	2012-04-26 11:53:54.307713748 +0100
***************
*** 1,3 ****
--- 1,8 ----
+ include(plumed.inc)
+ include(recon_patch.inc)
+ include(camshift_patch.inc)
+ add_definitions(-DPLUMED_GROMACS45) 
+ 
  set(GMXPREPROCESS_SOURCES 
      add_par.c       
      calc_verletbuf.c
***************
*** 61,67 ****
  endif(GMX_OPENMM)
  
  if(GMX_FAHCORE)
!   add_library(fahcore ${MDRUN_SOURCES})
  else(GMX_FAHCORE)
  
  list(APPEND GMX_EXTRA_LIBRARIES gmxpreprocess md)
--- 66,72 ----
  endif(GMX_OPENMM)
  
  if(GMX_FAHCORE)
!   add_library(fahcore ${MDRUN_SOURCES} ${PLUMED_SRC})
  else(GMX_FAHCORE)
  
  list(APPEND GMX_EXTRA_LIBRARIES gmxpreprocess md)
***************
*** 98,105 ****
  target_link_libraries(gmxcheck ${GMX_EXTRA_LIBRARIES})
  set_target_properties(gmxcheck PROPERTIES OUTPUT_NAME "gmxcheck${GMX_BINARY_SUFFIX}")
  
! add_executable(mdrun ${MDRUN_SOURCES})
! target_link_libraries(mdrun ${GMX_EXTRA_LIBRARIES} ${GMX_OPENMM_LIBRARIES})
  set_target_properties(mdrun PROPERTIES OUTPUT_NAME "mdrun${GMX_BINARY_SUFFIX}")
  
  # this is to circumvent the following MSVC error: 
--- 103,110 ----
  target_link_libraries(gmxcheck ${GMX_EXTRA_LIBRARIES})
  set_target_properties(gmxcheck PROPERTIES OUTPUT_NAME "gmxcheck${GMX_BINARY_SUFFIX}")
  
! add_executable(mdrun ${MDRUN_SOURCES} ${PLUMED_SRC})
! target_link_libraries(mdrun ${GMX_EXTRA_LIBRARIES} ${GMX_OPENMM_LIBRARIES} ${CAMSHIFT_LIBS})
  set_target_properties(mdrun PROPERTIES OUTPUT_NAME "mdrun${GMX_BINARY_SUFFIX}")
  
  # this is to circumvent the following MSVC error: 
EOF_EOF
